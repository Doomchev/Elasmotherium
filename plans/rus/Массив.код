шаблоны массив*, тип*Элемента, тип*Индекса, индекс**, размер*, измерени*, количеств*Измерений, заполнени*;

класс Массив<ТипЭлемента; ЛюбойЦелый ТипИндекса> {
	статичный неизменный ТипаИндекса неНайден = -1;
	
	создать(ТипаИндекса размер) долженБыть(размер >= 0);
	
	создать(ТипаИндекса размер, ТипаЭлемента заполнение) {
		создать(размер);
		для(ТипаИндекса и от 0 до размера) этот[и] = заполнению;
	}
	
	ТипаИндекса размер();
	
	ТипаЭлемента поИндексу(ТипаИндекса индекс) долженБыть(0 <= индекс < размер);
	
	поИндексу(ТипаИндекса индекс, ТипаЭлемента значение) долженБыть(0 <= индекс < размер);
	
	ТакаяЖе часть(Целое от, Целое количество) {
		должноБыть(количество >= 0 && 0 <= от <= размер - количество);
		ТакойЖе массив = создатьТакойЖе(количество);
		для(Целого и от 0 до количество) массив[и] = этот[от + и];
		вернуть массив;
	}
	
	копировать(Целое от, Целое количество, ТакойЖе массив, Цел позиция) {
		должноБыть(0 <= от < размер - количество && 0 <= позиция < массива.размер - количество);
		для(Целого и от 0 до количества) массив[и + позиция] = этот[от + и];
	}
	
  Вопрос равен(ТакойЖе строке) {
    если(размер != строки.размеру) вернуть нет;
    для(Целого и от 0 до размер) если(этот[и] неРавен строке[и]) вернуть нет;
    вернуть да;
  }
	
	диапазон(ТипаИндекса от, ТипаИндекса до, ТакоеЖе значение) {
		если(от < 0) от += размер;
		если(до < 0) до += размер;
		должноБыть(0 <= от <= до <= размер && значения.размер == до - от);
		значение.копировать(0, значение.размер, этот, от);
	}
	
	ТакойЖе диапазон(ТипаИндекса от, ТипаИндекса до) {
		если(от < 0) от += размер;
		если(до < 0) до += размер;
		должноБыть(0 <= от <= до <= размер);
		вернуть часть(от, до - от);
	}
	
	ТакойЖе диапазонОт(ТипаИндекса от) {
		если(от < 0) от += размер;
		должноБыть(0 <= от <= размер);
		вернуть часть(от, размер - от);
	}
	
	ТакойЖе диапазонДо(ТипаИндекса до) {
		если(до < 0) до += размер;
		должноБыть(0 <= до <= размер);
		вернуть часть(0, до);
	}
	
	ТипаИндекса индекс(ТипаЭлемента элемент) {
		для(ТипаИндекса и от 0 до размера) если(этот[и] равен элементу) вернуть и;
		вернуть неНайден;
	}
	
	Вопрос содержит(ТипаЭлемента элемент) {
		для(ТипаИндекса и от 0 до размер) если(этот[и] равен элементу) вернуть да;
		вернуть нет;
	}
}

секция ФиксированногоРазмера {
	класс Массив<ТипЭлемента, Целый фиксированныйРазмер; ЛюбойЦелый ТипИндекса> расширяет Массив<ТипЭлемента; ТипИндекса> {
		ТипаИндекса размер -> фиксированныйРазмер;
	}
}

секция Многомерный {
	класс Массив<Цел количествоИзмерений, ТипЭлемента; ЛюбойЦелый ТипИндекса> расширяет Массив<ТипЭлемента; ТипИндекса> {
		неизменный Массив<Цел, количествоИзмерений> _измерения;
		создать(Массив<Цел, количествоИзмерений> измерения) {
			Целый _размер = 1;
			для(Целого и от 0 до количестваИзмерений) _размер *= измерение[и];
			создать(_размер);
			_измерения = измерения;
		}
		Целый размер.поИндексу(ТипаИндекса индекс) {
			должноБыть(0 <= индекс < количествоИзмерений);
			вернуть _измерение[индекс];
		}
		Целый _индекс(Массив<ТипаИндекса> индексов) {
			долженБыть(индекса.размер равен количествуИзмерений);
			для(Целого и от 0 до количестваИзмерений) должноБыть(0 <= индекс[и] < _измерение[и]);
			Целое к = 0;
			для(Целого и от 0 до количестваИзмерений) к = к * _измерение[и] + индекс[и];
			вернуть к;
		}
		ТипаЭлемента поИндексу(Массив<ТипаИндекса> индексов) -> этот[_индекс[индекс]];
		поИндексу(Массив<ТипаИндекса> индекс, ТипЭлемента значение) этот[_индекс[индекс]] = значение;	
	}
}

секция ФиксированногоРазмераМногомерный {
	класс Массив<Целое количествоИзмерений, ТипЭлемента, Массив<Целое, количествоИзмерений> фиксированныеИзмерения; ЛюбогоЦелого ТипИндекса> расширяет Массив<ТипЭлемента, размер; ТипИндекса> {
		Целый размер() {
			Целый _размер = 1;
			для(Целого и от 0 до количестваИзмерений) _размер *= фиксированноеИзмерение[и];
			вернуть _размер;
		}
		Целый размер.поИндексу(ТипаИндекса индекс) {
			должноБыть(0 <= индекс < количествоИзмерений);
			вернуть фиксированноеИзмерение[индекс];
		}
		Целый _индекс(Массив<ТипаИндекса> индекс) {
			долженБыть(индекса.размер равен количествуИзмерений);
			для(Целого и от 0 до количестваИзмерений) должноБыть(0 <= индекс[и] < фиксированныеИзмерения[и]);
			Целое к = 0;
			для(Целого и от 0 до количестваИзмерений) к = к * фиксированноеИзмерение[и] + индекс[и];
			вернуть к;
		}
		ТипаЭлемента поИндексу(Массив<ТипаИндекса> индексов) -> этот[_индекс[индекс]];
		поИндексу(Массив<ТипаИндекса> индексов, ТипаЭлемента значение) этот[_индекс[индекс]] = значение;		
	}
}