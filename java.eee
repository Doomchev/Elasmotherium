comma=, 
plus= + 
codeBlock=
newl=\n\i
end=;\n\i
comma2=,\n\i

*:\c(*)
root:\c(*,end)

code:{\+\n\i\c(*,end);\-\n\i}
else:{\+\n\i\c(*,end);\-\n\i}

function:\type \x(\c(parameter,comma)) \(code)
functionCall:\0(\1)
new:new \0(\1)
parameters:\c(*,comma)
parameter:\?type[\(type) ]\x
this:this
name:\x

if:if(\(condition)) \(code)\?else[ else \(else)]
condition:\c(*)

for:for(\(init); \(condition); \(iteration)) \(code)
for_each:for(\(index) = 0; \(index) < \(collection).size; \(index)++) \(code)

do:do \(code)

return:return \0
return_null:return
break:break
end:end

variable:\?type[\(type) ]\?this[this.]\x\?subtype[<\c(subtype,comma)>]\?get[()]
integer:\x
decimal:\x
type:\x\?subtype[<\c(subtype,comma)>]
subtype:\x\?subtype[<\c(subtype,comma)>]

stringSequence:\c(*,plus)
string:"\x"

array:new Object[]{\c(*,comma)}

object:{\+\n\i\c(*,comma2)\-\n\i}
entry:\0 = \1
method:\?public[public ]\?static[static ]\(type) \x(\c(parameter,comma)) \(code)
constructor:\x(\c(parameter,comma)) \(code)
class:class \x {\+\n\i\c(*,newl)\-\n\i}
field:\?static[static ]\(type) \x\?default[ = \(default)]\?get[\(get)];
get:() \(code)

equate:\?type[\(type) ]\0 = \1
add:\0 += \1
subtract:\0 -= \1
multiply:\0 *= \1
divide:\0 /= \1
increment: \0++
decrement: \0--

dot:\0.\1
atIndex:\0[\1]
brackets:(\0)

addition:\0 + \1
subtraction:\0 - \1
multiplication:\0 * \1
division:\0 / \1
mod:\0 % \1
bitAnd:\0 & \1
bitOr:\0 | \1
equal:\0 == \1
notequal:\0 != \1
less:\0 < \1
lessOrEqual:\0 <= \1
more:\0 > \1
moreOrEqual:\0 >= \1
and:\0 && \1
or:\0 || \1
ifOp:\0 ? \1 : \2