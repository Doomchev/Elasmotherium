variable {
  value.resolve(this);
  [this]VarEquate;
}

return {
  v0.resolve(currentFunction);
  [currentFunction]Return;
}

// get object

variable.getObject {
  [this]VarPush;
  setParameter(this);
}

field.getObject {
  [this]FieldPush(object);
  setParameter(this);
}

brackets.getObject {
  v0.getObject;
}

at.getObject {
  v0.getObject;
  v1.resolve(Int);
  [this]getAtIndex;
  setParameter(this);
}

// equate

equate {
  v0.equate(v1);
}

variable.equate {
  param.resolve(this);
  [this]VarEquate;
}

field.equate {
  param.resolve(this);
  [this]FieldEquate(object);
}

dot.equate {
  getField;
  param.resolve(this);
  [this]FieldEquate(last);
}

at.equate {
  v0.getObject;
  v1.resolve(Int);
  getSubType;
  param.resolve(this);
  [this]SetAtIndex;
}

// increment

increment {
  v0.increment;
}

variable.increment {
  [this]VarIncrement;
}

field.increment {
  [this]FieldIncrement(object);
}

dot.increment {
  getField;
  [this]FieldIncrement(last);
}

// resolution

variable.resolve {
  [this]VarPush;
  convert(this, param);
}

field.resolve {
  [this]FieldPush(object);
  convert(this, param);
}

dot.resolve {
  getField;
  [this]FieldPush(last);
  convert(this, param);
}

const.resolve {
  [param]Push;
}

at.resolve {
  v0.getObject;
  v1.resolve(Int);
  getSubType;
  [this]GetAtIndex;
  convert(this, param);
}

// arithmetic

brackets.resolve {
  v0.resolve(param);
}

negative.resolve {
  v0.resolve(Int);
  [Int]Negative;
}

addition.resolve {
	v0.resolve(param);
	v1.resolve(param);
  [param]Add;
}

subtraction.resolve {
	v0.resolve(Int);
	v1.resolve(Int);
  [Int]Subtract;
  convert(Int, param);
}

multiplication.resolve {
	v0.resolve(Int);
	v1.resolve(Int);
  [Int]Multiply;
  convert(Int, param);
}

division.resolve {
	v0.resolve(Int);
	v1.resolve(Int);
  [Int]Divide;
  convert(Int, param);
}

mod.resolve {
	v0.resolve(Int);
	v1.resolve(Int);
  [Int]Mod;
  convert(Int, param);
}

equal.resolve {
  v0.resolve(Int);
  v1.resolve(Int);
  [Int]IsEqual;
  convert(Bool, param);
}

less.resolve {
  v0.resolve(Int);
  v1.resolve(Int);
  [Int]IsLess;
  convert(Bool, param);
}

lessOrEqual.resolve {
  v0.resolve(Int);
  v1.resolve(Int);
  [Int]IsLessOrEqual;
  convert(Bool, param);
}

more.resolve {
  v0.resolve(Int);
  v1.resolve(Int);
  [Int]IsMore;
  convert(Bool, param);
}

ifOp.resolve {
  v0.resolve(Bool);
  IfFalseGoTo(#opElse);
  v1.resolve(param);
  GoTo(#opEnd);
  #opElse:
  v2.resolve(param);
  #opEnd:
}

// blocks

if {
  $condition.resolve(Bool);
  IfFalseGoTo(#endIf);
  process($code);
  #endIf:
}

if_else {
  $condition.resolve(Bool);
  IfFalseGoTo(#else);
  process($code);
  GoTo(#endIf);
  #else:
  process($else);
  #endIf:
}

repeat {
  #start:
  process($code);
  GoTo(#start);
  #end:
}

for_to {
  process($variable);
  $variable.equate($from);
  #start:
  $variable.resolve(Int);
  $to.resolve($variable);
  [Int]IsLessOrEqual;
  IfFalseGoTo(#end);
  process($code);
  $variable.increment;
  GoTo(#start);
  #end:
}

for_until {
  process($variable);
  $variable.equate($from);
  #start:
  $variable.resolve(Int);
  $until.resolve($variable);
  [Int]IsLess;
  IfFalseGoTo(#end);
  process($code);
  $variable.increment;
  GoTo(#start);
  #end:
}

for_collection {
  process($item);
  $collection.resolve(Object);
  CollectionToIterator;
  ObjectVarEquate(@iterator);
  #start:
  @iterator.resolve(Object);
  IteratorHasNext;
  IfFalseGoTo(#end);
  @iterator.resolve(Object);
  [$item]IteratorNext;
  [$item]VarEquate($item);
  process($code);
  GoTo(#start);
  #end:
}

break {
  GoTo(#end);
}