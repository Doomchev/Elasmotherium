package vm;

import base.Base;
import base.Module;
import exception.ElException;
import vm.call.VMFunctionCall;
import vm.values.VMValue;

import javax.swing.*;
import java.awt.*;
import java.util.Arrays;

public class VMBase extends Base{
  private static final int STACK_SIZE = 1024, COMMANDS_SIZE = 65536;
  
  protected static ValueType[] typeStack = new ValueType[STACK_SIZE];
  
  protected static long[] i64Stack = new long[STACK_SIZE];
  protected static double [] f64Stack = new double[STACK_SIZE];
  protected static String[] stringStack = new String[STACK_SIZE];
  protected static boolean[] booleanStack = new boolean[STACK_SIZE];
  protected static VMValue[] valueStack = new VMValue[STACK_SIZE];
  
  protected static VMFunctionCall[] callStack = new VMFunctionCall[STACK_SIZE];
  protected static int stackPointer = -1, callStackPointer = -1;
  protected static VMFunctionCall currentCall
      = new VMFunctionCall(0, 0);
  protected static VMCommand[] commands = new VMCommand[COMMANDS_SIZE];
  protected static JFrame frame;
  protected static boolean usesWindow = false, usesConsole = false;
  
  public static int currentCommand = -1, initialStack;
  public static Graphics currentGraphics;
  
  public enum ValueType {UNDEFINED, I64, F64, STRING, BOOLEAN, OBJECT};
  
  public static void append(VMCommand command, int line) {
    currentCommand++;
    command.proLine = line;
    commands[currentCommand] = command;
  }
  
  public static void appendLog(VMCommand command, int proLine) {
    if(log) append(command, proLine);
  }

  public static void execute(boolean showCommands, Module module, int renderPos) {
    if(log) {
      Arrays.fill(typeStack, ValueType.UNDEFINED);
      if(log) printChapter("Generated bytecode");
      for(int index = 0; index <= currentCommand; index++) {
        VMCommand command = commands[index];
        System.out.println(String.format("%03d", index) + "("
            + command.proLine + "): " + command.toString());
      }
      printChapter("Bytecode execution");
    }
    
    initialStack = currentFunction.getAllocation() - 1;
    stackPointer = initialStack;
    currentCommand = 0;

    workingPath = module.path;

    if(usesWindow) {
      frame = new JFrame() {
        @Override
        public void paint(Graphics graphics) {
          currentGraphics = graphics;
          currentCommand = renderPos;
          execute(showCommands);
        }
      };

      frame.setExtendedState(frame.getExtendedState() | JFrame.MAXIMIZED_BOTH);
      frame.setDefaultCloseOperation(WindowConstants.EXIT_ON_CLOSE);

      execute(showCommands);
      frame.setVisible(true);
    } else {
      execute(showCommands);
    }
  }

  public static void execute(boolean showCommands) {
    while(currentCommand >= 0) {
      if(showCommands) System.out.println(currentCommand + ": "
          + commands[currentCommand].toString());

      try {
        commands[currentCommand].execute();
      } catch (ElException ex) {
        error("Bytecode execution error", ex.message);
      }

      if(showCommands) {
        StringBuilder stack = new StringBuilder();
        for(int index = 0; index <= stackPointer; index++)
          switch(typeStack[index]) {
            case UNDEFINED -> stack.append("- ");
            case I64 -> stack.append(i64Stack[index]).append(" ");
            case F64 -> stack.append(f64Stack[index]).append(" ");
            case STRING -> stack.append("\"").append(stringStack[index]).append("\" ");
            case BOOLEAN -> stack.append(booleanStack[index] ? "true " : "false ");
            case OBJECT -> stack.append(valueStack[index].toString()).append(" ");
          }
        System.out.println("Stack: " + stack);
      }
    }
  }
}
