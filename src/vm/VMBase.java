package vm;

import vm.values.ObjectEntity;
import base.Base;
import base.ElException;
import base.Module;
import java.util.Arrays;
import javax.swing.JFrame;
import vm.values.VMValue;

public class VMBase extends Base{
  private static final int STACK_SIZE = 16, COMMANDS_SIZE = 256;
  
  protected static ValueType[] typeStack = new ValueType[STACK_SIZE];
  
  protected static long[] i64Stack = new long[STACK_SIZE];
  protected static double [] f64Stack = new double[STACK_SIZE];
  protected static String[] stringStack = new String[STACK_SIZE];
  protected static boolean[] booleanStack = new boolean[STACK_SIZE];
  protected static VMValue[] objectStack = new VMValue[STACK_SIZE];
  
  protected static VMFunctionCall[] callStack = new VMFunctionCall[STACK_SIZE];
  protected static int stackPointer = -1, callStackPointer = -1;
  protected static VMFunctionCall currentCall = new VMFunctionCall(0, 0);
  protected static VMCommand[] commands = new VMCommand[COMMANDS_SIZE];
  protected static JFrame frame;
  protected static boolean usesWindow = false, usesConsole = false;
  
  public static int currentCommand = -1;
  
  public enum ValueType {UNDEFINED, I64, F64, STRING, BOOLEAN, OBJECT};
  
  public static void append(VMCommand command) {
    currentCommand++;
    commands[currentCommand] = command;
  }
  
  public static void appendLog(VMCommand command) {
    if(log) 
    append(command);
  }

  public static void execute(boolean showCommands, Module module) {
    if(log) {
      Arrays.fill(typeStack, ValueType.UNDEFINED);
      if(log) printChapter("Generated bytecode");
      for(int index = 0; index <= currentCommand; index++)
        System.out.println(String.format("%03d", index)
            + ": " + commands[index].toString());
      printChapter("Bytecode execution");
    }
    
    if(usesWindow) {
      frame = new JFrame();
      frame.setVisible(true);
      frame.setExtendedState(frame.getExtendedState() | JFrame.MAXIMIZED_BOTH);
    }
    
    stackPointer = module.getAllocation() - 1;
    currentCommand = 0;
    while(true) {
      if(showCommands) System.out.println(currentCommand + ": "
          + commands[currentCommand].toString());

      try {
        commands[currentCommand].execute();
      } catch (ElException ex) {
        error("Bytecode execution error", ex.message);
      }

      if(showCommands) {
        String stack = "";
        for(int index = 0; index <= stackPointer; index++)
          switch(typeStack[index]) {
            case UNDEFINED:
              stack += "- ";
              break;
            case I64:
              stack += i64Stack[index] + " ";
              break;
            case F64:
              stack += f64Stack[index] + " ";
              break;
            case STRING:
              stack += "\"" + stringStack[index] + "\" ";
              break;
            case BOOLEAN:
              stack += booleanStack[index] ? "true " : "false ";
              break;
            case OBJECT:
              stack += objectStack[index].toString() + " ";
              break;
          }
        System.out.println("Stack: " + stack);
      }
    }
  }
}
