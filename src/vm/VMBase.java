package vm;

import vm.call.VMFunctionCall;
import base.Base;
import base.ElException;
import base.Module;
import java.awt.Graphics;
import java.util.Arrays;
import javax.swing.JFrame;
import javax.swing.WindowConstants;
import vm.values.VMValue;

public class VMBase extends Base{
  private static final int STACK_SIZE = 16, COMMANDS_SIZE = 256;
  
  protected static ValueType[] typeStack = new ValueType[STACK_SIZE];
  
  protected static long[] i64Stack = new long[STACK_SIZE];
  protected static double [] f64Stack = new double[STACK_SIZE];
  protected static String[] stringStack = new String[STACK_SIZE];
  protected static boolean[] booleanStack = new boolean[STACK_SIZE];
  protected static VMValue[] objectStack = new VMValue[STACK_SIZE];
  
  protected static VMFunctionCall[] callStack = new VMFunctionCall[STACK_SIZE];
  protected static int stackPointer = -1, callStackPointer = -1;
  protected static VMFunctionCall currentCall = new VMFunctionCall(0, 0);
  protected static VMCommand[] commands = new VMCommand[COMMANDS_SIZE];
  protected static JFrame frame;
  protected static boolean usesWindow = false, usesConsole = false;
  
  public static int currentCommand = -1, initialStack;
  public static Graphics currentGraphics;
  
  public enum ValueType {UNDEFINED, I64, F64, STRING, BOOLEAN, OBJECT};
  
  public static void append(VMCommand command) {
    currentCommand++;
    commands[currentCommand] = command;
  }
  
  public static void appendLog(VMCommand command) {
    if(log) 
    append(command);
  }

  public static void execute(boolean showCommands, Module module) {
    if(log) {
      Arrays.fill(typeStack, ValueType.UNDEFINED);
      if(log) printChapter("Generated bytecode");
      for(int index = 0; index <= currentCommand; index++)
        System.out.println(String.format("%03d", index)
            + ": " + commands[index].toString());
      printChapter("Bytecode execution");
    }
    
    initialStack = module.getAllocation() - 1;
    stackPointer = initialStack;
    currentCommand = 0;

    workingPath = module.path;
    
    if(usesWindow) {
      frame = new JFrame() {
        @Override
        public void paint(Graphics graphics) {
          currentGraphics = graphics;
          execute(showCommands);
        }
      };
      frame.setVisible(true);
      frame.setExtendedState(frame.getExtendedState() | JFrame.MAXIMIZED_BOTH);
      frame.setDefaultCloseOperation(WindowConstants.EXIT_ON_CLOSE);
    } else {
      execute(showCommands);
    }
  }
  
  public static void execute(boolean showCommands) {
    while(currentCommand >= 0) {
      if(showCommands) System.out.println(currentCommand + ": "
          + commands[currentCommand].toString());

      try {
        commands[currentCommand].execute();
      } catch (ElException ex) {
        error("Bytecode execution error", ex.message);
      }

      if(showCommands) {
        StringBuilder stack = new StringBuilder();
        for(int index = 0; index <= stackPointer; index++)
          switch(typeStack[index]) {
            case UNDEFINED:
              stack.append("- ");
              break;
            case I64:
              stack.append(i64Stack[index]).append(" ");
              break;
            case F64:
              stack.append(f64Stack[index]).append(" ");
              break;
            case STRING:
              stack.append("\"").append(stringStack[index]).append("\" ");
              break;
            case BOOLEAN:
              stack.append(booleanStack[index] ? "true " : "false ");
              break;
            case OBJECT:
              stack.append(objectStack[index].toString()).append(" ");
              break;
          }
        System.out.println("Stack: " + stack);
      }
    }
  }
}
