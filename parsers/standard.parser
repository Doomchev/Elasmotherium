/// symbols

quotes = " "
digit = 0-9
letter = a-z A-Z
idSymbol = digit letter
fileSymbol = digit letter .
spacing = tab space
nothing = tab space newline
op = + - * / =



/// errors

ERROR expected: \0 expected
ERROR syntaxError: Syntax error
ERROR invalid: Invalid \0
ERROR error: \0



/// default symbol switch

DEFAULT nothing: >>
DEFAULT "//": >> slashComment()
DEFAULT "/*": >> multiLineComment()



/// base

root: {
	"import": >> id() CREATE(module) EXPECT(";") root
  other: сodeLines
}


сodeLines: {
  eof: RETURN
  "}": RETURN
  other: codeLine()
}

code: CREATE(code) {
  "{": >> сodeLines() EXPECT("}") RETURN
  other: codeLine
}



/// code line

codeLine: {
	letter: id() {
    // Type var
    // Type function
    letter: CREATE(link) def
    // Type<Type> var
    // Type<Type> function
    "<": >> type() def
    // function(
    "(": >> {
      ")": >> {
        // function() codeLine;
        // function() {code}
        // function() -> value;
        "{", "-", letter: CREATE(function) functionCode
        // call();
        // call().field
        // call().method(
        // call()[index]
        other: CREATE(formula) CREATE(link) MOVE(link, formula) CREATE(parameters) callParameterEnd
      }
      //function(Type
      //call(value
      letter: id() {
        //function(Type name
        letter: CREATE(link) CREATE(function) id() CREATE(variable) MOVE(link, variable) functionParamDefault
        //function(Type< name
        //function(var
        other: CREATE(link) CREATE(formula) CREATE(link) MOVE(link, formula) CREATE(parameters) CREATE(formula) MOVE(link, formula) separator() MOVE(formula, parameters) {
          ",": >> callParameter
          ")": >> callParameterEnd
          other: expected(", or )")
        }
      }
      other: CREATE(formula) CREATE(link) MOVE(link, formula) functionCall
    }
    // var operator;
    // object.
    // object[
    other: CREATE(link) CREATE(formula) MOVE(link, formula) var
  }
  
  /// keywords
  
  "class": >> class() MOVE(class, code) RETURN
  "for": >> for
  "repeat": >> CREATE(block, repeat) code() SET(code, code) MOVE(block, code) RETURN
  "if": >> EXPECT("(")  formula() {
    "then": then
    other: CREATE(block, if) SET(condition, formula) EXPECT(")") code() SET(code, code) {
      "else": >> code() SET(else, code) SET(if_else) MOVE(block, code) RETURN
      other: MOVE(block, code) RETURN
    }
  }
  "break": >> CREATE(break) MOVE(call, code) codeLineEnd
  "return": >> CREATE(return) {
    ";": >> MOVE(call, code) RETURN
    other: formula() MOVE(formula, call) MOVE(call, code) codeLineEnd
  }
  
  /// separators
  
  "[": >> CREATE(formula) list() MOVE(list, formula) {
    "[": >> index
    ".": >> dot
    other: expected("[ or .")
  }
  ";": >> RETURN
  other: syntaxError
}

codeLineEnd: EXPECT(";") RETURN

if: 

// Type[<Type...>] var
// Type[<Type...>] function
def: id() {
  // Type function(
  "(": >> CREATE(function) MOVE(link, function) functionParameter
  // Type var = value;
  // Type var;
  ",", ";", "=": varDefault
  other: syntaxError
}

varDefault: CREATE(variable) {
  // Type var = value
  "=": >> formula() MOVE(formula, variable) varEnd
  other: varEnd
}

varEnd: {
  // Type var,
  ",": >> DUP(link) MOVE(link, variable) MOVE(variable, code) id() varDefault
  // Type var;
  ";": >> MOVE(link, variable) MOVE(variable, code) RETURN
  other: syntaxError
}

// Type function(Type
functionParameter: {
  // Type function(Type var
  letter: id() {
    // function(Type var
    letter: CREATE(link) id() CREATE(variable) MOVE(link, variable) functionParamDefault
    // function(Type<Type> var
    "<": >> type() id() CREATE(variable) MOVE(link, variable) functionParamDefault
    // function(var = formula
    "=": expected("Type")
    // function(var,
    // function(var)
    ",", ")": expected("Type for parameter")
    other: expected("Identifier or subtype")
  }
  // Type function()
  ")": >> functionCode
  other: expected("Identifier or )")
}

functionParamDefault: {
  // Type[<Type>] var = default
  "=": >> formula(call) MOVE(formula, variable) functionParamEnd
  // Type[<Type>] var
  other: functionParamEnd
}

functionParamEnd: MOVE(variable, function) {
  // function(params, 
  ",": >> functionParameter
  // function(params)
  ")": >> functionCode
  other: expected(", or )")
}

functionCode: {
  // [Type ]function([params]) -> expression;
  "->": >> formula() CREATE(return) MOVE(formula, call) CREATE(code) MOVE(call, code) MOVE(code, function) functionEnd
  // [Type ]function([params]) codeLine;
  ";": functionEnd
  other: code() MOVE(code, function) functionEnd
}

functionEnd: MOVE(function, code) RETURN



/// comments

slashComment: {
  eof: RETURN
  "/", nothing, other: >>
  newline: >> RETURN
}

multiLineComment: {
  "*/": >> RETURN
  "/", nothing, other: >>
  eof: expected("*/")
}



/// id

id: {
  letter: CLEAR >> {
    idSymbol: >>
    "/", nothing, other: CREATE(id) RETURN
  }
  other: expected("Identifier")
}



/// for loop

for: EXPECT("(") CREATE(block, for) {
  // for(Type variable = formula; condition)
  // for(Type variable = formula; condition; iterator)
	letter: variable() SET(variable, variable) {
    "=": >> formula() SET(init, formula) EXPECT(";") formula() SET(condition, formula) {
      ")": >> forEnd
      other:  EXPECT(";") CREATE(code) id() var() SET(iterator, code) forEnd
    }
    "from": >> formula() SET(from, formula) {
      // for(Type variable from start to
      "to": >> formula() SET(to, formula) SET(for_to) forEnd
      // for(Type variable from start until
      "until": >> formula() SET(until, formula) SET(for_until) forEnd
      other: syntaxError
    }
    other: syntaxError
  }
  // for(each Type variable in collection)
  "each": >> variable() SET(item, variable) {
    "in": >> formula() SET(collection, formula) CBV(iterator) SET(for_collection) forEnd
    other: syntaxError
  }
	other: syntaxError
}

forEnd: EXPECT(")") code() SET(code, code) MOVE(block, code) RETURN



/// variable

variable: id() {
	// Type0<Type1>
	"<": >> type()
  // Type name =
  letter: CREATE(link) varName
  // name =
  other: CREATE(variable) RETURN
}

varName: id() CREATE(variable) MOVE(link, variable) RETURN



/// subtype

type: CREATE(link) subtype

subtype: id() CREATE(link) {
  "<": >> subtype()
  ",": >> MOVE(link) subtype
  ">": >> MOVE(link) RETURN
  other: error("Error in type syntax")
}



/// var

var: {
  ".": >> dot
  "(": >> functionCall
  "[": >> index
  op: operator
  "//": >> slashComment()
  "/*": >> multiLineComment()
  other: syntaxError
}



/// dot

dot: MOVE(dot, formula) {
  letter: id() CREATE(link) MOVE(link, formula) var
  other: expected("Identifier")
}



/// index

index: MOVE(at, formula) CREATE(parameters) indexValue

indexValue: formula() MOVE(formula, parameters) {
  ",": >> indexValue
  "]": >> afterIndex
  other: syntaxError
}

afterIndex: MOVE(parameters, formula) {
  "[": >> index
  ".": >> dot
  "(": >> functionCall
  op: operator
  "//": >> slashComment()
  "/*": >> multiLineComment()
  other: syntaxError
}



/// function call

functionCall: CREATE(parameters) {
  ")": >> callParameterEnd
  other: callParameter
}

callParameter: formula() MOVE(formula, parameters) {
  ",": >> callParameter
  ")": >> callParameterEnd
  other: expected(", or )")
}

callParameterEnd: CREATE(call) {
  "{": >> CREATE(id) CREATE(class) classBody() MOVE(class, call) afterCallParameterEnd
  other: afterCallParameterEnd
}

afterCallParameterEnd: MOVE(call, formula) MOVE(parameters, formula) afterCallParameter

afterCallParameter: {
  ".": >> dot
  "(": >> functionCall
  "[": >> index
  ";": MOVE(formula, code) RETURN
  other: syntaxError
}



/// operator

operator: {
  "++": >> CREATE(increment) unaryOperator
  "--": >> CREATE(decrement) unaryOperator
  "=": >> CREATE(equate) binaryOperator
  "+=": >> CREATE(add) binaryOperator
  "-=": >> CREATE(subtract) binaryOperator
  "/=": >> CREATE(divide) binaryOperator
  "*=": >> CREATE(multiply) binaryOperator
  other: RETURN
}

unaryOperator: MOVE(formula, call) MOVE(call, code) EXPECT(";") RETURN

binaryOperator: MOVE(formula, call) formula() MOVE(formula, call) MOVE(call, code) EXPECT(";") RETURN




/// formula

formula: CREATE(formula) value
value: {
  ")", "]", "}", ",": RETURN
  digit: number() MOVE(value, formula) separator
  letter: id() formulaId
  "if": >> EXPECT("(") CREATE(ifOp) formula() MOVE(formula, call) {
    "then": >> then 
    other: syntaxError
  }
  "-": >> CREATE(negative) formula() MOVE(formula, call) MOVE(call, formula) separator
  "!": >> formula() CREATE(not) MOVE(formula, call) MOVE(call, formula) separator
  "(": >> formula() EXPECT(")") CREATE(brackets) MOVE(formula, call) MOVE(call, formula) separator
  "[": >> list() MOVE(list, formula) separator
  "{": >> map() MOVE(map, formula) separator
  quotes: >> CLEAR string
  other: expected("Value")
}

then: formula() MOVE(formula, call) {
  "else": >> formula() MOVE(formula, call) EXPECT(")") MOVE(call, formula) separator
  other: syntaxError
}

formulaId: {
	// var <
	// Type<
	"<": >> {
		// var0 < var1
		// Type0<Type1
		letter: id() {
			// Type0<Type1<Type2
			// Type0<Type1, Type2
			// Type0<Type1>
			"<", ",", ">": CREATE(link) CREATE(link) linkParameterSubtype
			// var0 < var1 ...
			other: CREATE(link) CREATE(link) MOVE(link, formula) MOVE(less, formula) MOVE(link, formula) separator
		} 
		// var < value
		other: CREATE(link) MOVE(link, formula) MOVE(less, formula) value
	}
  // var <= value
  "<=": >> CREATE(link) MOVE(link, formula) MOVE(lessOrEqual, formula) value
	"/", other: CREATE(link) MOVE(link, formula) separator
}

linkParameterSubtype: {
  "<": >> subtype() MOVE(link) linkParameterEnd
  other: linkParameterEnd
}

linkParameterEnd: MOVE(link, link) {
  //Type0<Type1>
  ">": >> MOVE(link, formula) EXPECT("(") parameters
  ",": >> id() CREATE(link) linkParameter
  other: SyntaxError
}



/// separator

separator: {
	".": >> MOVE(dot, formula) value
  "..": RETURN
  "(": >> parameters
  "[": >> valueIndex
  "+": >> MOVE(addition, formula) value
  "-": >> MOVE(subtraction, formula) value
  "*": >> MOVE(multiplication, formula) value
  "/": >> MOVE(division, formula) value
  "//": >> slashComment()
  "/*": >> multiLineComment()
  "==": >> MOVE(equal, formula) value
  "!=": >> MOVE(notEqual, formula) value
  "<": >> MOVE(less, formula) value
	"<=": >> MOVE(lessOrEqual, formula) value
  ">" : >> MOVE(more, formula) value
  ">=": >> MOVE(moreOrEqual, formula) value
  "&": >> MOVE(bitAnd, formula) value
  "&&": >> MOVE(and, formula) value
  "|": >> MOVE(bitOr, formula) value
  "|": >> MOVE(or, formula) value
	"%": >> MOVE(mod, formula) value
  other: RETURN
}

valueIndex: MOVE(at, formula) CREATE(parameters) valueIndexValue

valueIndexValue: formula() MOVE(formula, parameters) {
  ",": >> valueIndexValue
  "]": >> MOVE(parameters, formula) separator
  other: syntaxError
}



/// parameters

parameters: CREATE(parameters) {
  ")": >> parameterEnd
  other: parameter
}

parameter: formula() MOVE(formula, parameters) {
  ",": >> parameter
  ")": >> parameterEnd
  other: expected(", or )")
}

parameterEnd: CREATE(call) MOVE(call, formula) MOVE(parameters, formula) separator



/// number

number: CLEAR >> {
  digit: >>
  ".": {
    digit: >>
    "/", nothing, other: CREATE(const, float) RETURN
  }
  "/", nothing, other: CREATE(const, int) RETURN
}



/// string

string: {
  "\(": CREATE(stringSequence) stringBrackets
  quotes: CREATE(const, string) >> MOVE(const, formula) separator
  "/", nothing, other: >>
}

stringBrackets: CREATE(const, string) >> >> MOVE(const, stringSequence) stringValue

stringValue: formula() EXPECT(")") MOVE(formula, stringSequence) CLEAR stringSequence

stringSequence: {
  "\(": stringBrackets
  quotes: CREATE(const, string) >> MOVE(const, stringSequence) MOVE(stringSequence, formula) separator
  other: >>
}



/// list

list: CREATE(list) {
	"]": >> RETURN
	other: listItem
}

listItem: formula() MOVE(formula, list) {
  ",": >> listItem
  "]": >> RETURN
  other: expected(", or ]")
}



/// map

map: CREATE(map) mapEntry
mapEntry: {
  letter: id() CREATE(entry) EXPECT(":") formula() MOVE(formula, entry) MOVE(entry, map)
	",": >>
  "}": >> MOVE(map, formula) separator
  other: expected("Identifier or }")
}



/// class definition

class: id() CREATE(class) {
  "<": >> classParameter
  other: classExtends
}

classParameter: id() CREATE(classParameter) MOVE(classParameter, class) {
  ",": >> classParameter
  ">": >> classExtends
  other: syntaxError
}

classExtends: {
  "extends": >> id() CREATE(link) MOVE(link, class) classBracket
  other: classBracket
}

classBracket: {
  "{": >> classBody
  ";": >> RETURN
  other: syntaxError
}

classBody: {
  // Type var
  // Type function
  // method(
  letter: id() {
    letter: CREATE(link) id() {
      // Type var,
      // Type var;
      // Type var = value
      ",", ";", "=": classFieldValue
      // Type method(
      "(": >> CREATE(function) MOVE(link, function) methodParameter
      other: syntaxError
    }
    // Type0<Type1> var
    // Type0<Type1> method
    "<": >> type() id() {
      "(": >> CREATE(function) methodParameter
      other: classFieldValue
    }
    // method(
    "(": >> CREATE(function) methodParameter
    other: syntaxError
  }
  "create": >> EXPECT("(") CREATE(constructor) methodParameter
  "}": >> RETURN
  other: syntaxError
}

classFieldValue: CREATE(variable) {
  // Type field = value
  "=": >> formula() MOVE(formula, variable) classFieldEnd
  other: classFieldEnd
}

classFieldEnd: {
  // Type field,
  ",": >> DUP(link) MOVE(link, variable) MOVE(variable, class) id() classFieldValue
  // Type field;
  ";": >> MOVE(link, variable) MOVE(variable, class) classBody
  other: syntaxError
}

methodParameter: {
  letter: id() {
    // method(Type var
    letter: CREATE(link) id() CREATE(variable) MOVE(link, variable) methodParamDefault
    // method(Type<Type> var
    "<": >> type() id() CREATE(variable) MOVE(link, variable) methodParamDefault
    // method(var = formula
    "=": expected("Type")
    // method(var,
    // method(var)
    ",", ")": expected("Type for parameter")
    other: expected("Identifier or subtype")
  }
  // method(field.var
  "field.": >> id() CREATE(field) methodParamDefault
  // Type method()
  ")": >> methodCode
  other: expected("Identifier or )")
}

methodParamDefault: {
  // Type[<Type>] var = default
  "=": >> formula() MOVE(formula, variable) methodParamEnd
  // Type[<Type>] var
  other: methodParamEnd
}

methodParamEnd: MOVE(variable, function) {
  // method(params, 
  ",": >> methodParameter
  // method(params)
  ")": >> methodCode
  other: expected(", or )")
}

methodCode: {
  // [Type ]method([params]) -> expression;
  "->": >> formula() CREATE(return) MOVE(formula, call) CREATE(code) MOVE(call, code) MOVE(code, function) EXPECT(";") methodEnd
  // [Type ]method([params]) codeLine;
  ";": >> methodEnd
  other: code() MOVE(code, function) methodEnd
}

methodEnd: MOVE(function, class) classBody